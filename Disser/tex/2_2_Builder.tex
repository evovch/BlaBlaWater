\section{``CATIA-GDML geometry builder''}\label{sec:Builder}

``CATIA-GDML geometry builder'' (далее просто ``Builder'') представляет собой набор документов-шаблонов и макропрограмм для САПР CATIA~v5 вместе с настройками окружения и инструкциями к применению стандартных средств CATIA~v5. ``Builder'' ставит своей задачей упростить процесс создания CSG моделей с иерархией объёмов, напрямую совместимых с GEANT/ROOT.

Центральная идея ``Builder'' заключается в правилах соответствия сущностей CATIA~v5 и сущностей геометрии в GEANT/ROOT. Это соответствие делает возможным конвертацию MC-модели в CATIA~v5 в любой внешний файл с целью дальнейшего импорта в ROOT/GEANT. В качестве формата для обмена был выбран XML-подобный формат GDML (geometry description markup language), разработанный в CERN, для которого в GEANT4 и ROOT реализованы методы импорта и экспорта.

Вся геометрия установки создаётся в одном документе типа CATProduct. Объёму соответствует деталь, хранящаяся в файле типа CATPart. Форме соответствует главное тело детали, по умолчанию называемое PartBody. В CATIA не записывается описание материала так, как это принято в GEANT/ROOT, а сохраняется только имя материала в пользовательском параметре Material. Это возможно по той причине, что существует практика хранить описание материалов во внешнем файле или базе данных, считывать его перед выполнением моделирования и приписывать объёмам в соответствии с именами. Для обозначения физического объёма $B$ внутри $A$ в структуре документа, описывающего объём $A$, создаются тела Body.A.*, где * по умолчанию обозначает номер вхождения, но допускается запись любой идентифицирующей строки.

\textbf{Может быть частично перенести в описание методов описания геометрии в GEANT/ROOT.}
Также в ``Builder'' предусмотрена возможность задания геометрии некоторыми продвинутыми методами, специфичными для GEANT/ROOT. В GEANT/ROOT существует тип объёмов, называемый Asssembly, который характеризуется тем, что он не имеет формы и материала. Практически объём типа Assembly является контейнером без границ, который объединяет свои дочерние объёмы, что особенно удобно как минимум в двух случаях. Во-первых, если необходимо многократно позиционировать группу объёмов, которую невозможно охватить простой формой. Во-вторых, если преобразование координат при позиционировании одного или группы объёмов имеет сложную структуру и удобно представить его как суперпозицию двух преобразований. Как частный случай можно упомянуть ситуацию, когда какой-либо параметр преобразования является параметром модели (см. секцию~\ref{sec:Parameterization})

Один из плюсов ``Builder'' заключается в том, что пользователю предоставляется возможность работать с полноценной инженерной моделью и MC-моделью в одной и той же среде, имеющей широкие возможности для анализа и редактирования геометрии. ``Builder'' не ставит своей задачей перевод модели из одного геометрического представления в другой, но значительно ускоряет процесс создания одной геометрии, на основе другой. Также важно отметить, что подходы к геометрическому моделированию в САПР подразумевают широкое использование параметров --- практически все размеры, значения поворотов и сдвигов, количество вхождений в массивы и прочие числа, определяющие форму и структуру модели, могут подвергаться изменению на любом этапе. Если в процесе построения модели этот принцип параметризированного моделирования нарушается, САПР предупреждает пользователя перед выполнением операции, которая приведёт к разрыву связи с параметром. В CATIA~v5 при изменении каких-либо параметров геометрическая модель перестраивается интерактивно --- от долей секунды до нескольких секунд в зависимости от сложности модели.  Эта стандартная черта САПР очень удобна при работе с MC-моделями и отсутствует, например, в GEANT и ROOT.

``Builder'' включает в себя файлы, в которых специальным образом построены примитивы GEANT/ROOT, позволяющие пользователю при построении MC-модели не вникать в подробности реализации, а использовать их практически как и в процессе создания геометрии средствами ROOT или GEANT. ``Builder'' также включает в себя макропрограммы для CATIA~v5, которые также ставят своей задачей сделать процесс построения геометрии в ``Builder'' максимально похожим на процесс построения геометрии в GEANT или ROOT. Основной макрос --- это конвертер ``CATIA2GDML'', который проецирует дерево построения модели в CATIA в GDML файл. Также разработан обратный конвертер ``GDML2CATIA'' для импорта GDML файлов.

Целевая аудитория ``CATIA-GDML geometry builder'' --- физики, владеющие CATIA~v5 на базовом уровне, и инженеры, продвинутые пользователи САПР, изучившие способ представления геометрии в GEANT/ROOT хотя бы на теоретическом уровне. \textbf{Есть опыт, который показывает, что для достижения такого уровня как физикам, так и инженерам, достаточно прохождения двухнедельного курса.}

Предлагается новый алгоритм работы, в котором ``Builder'' используется как многофункциональный инструмент. Описанный ниже алгоритм сформулирован на успешном опыте разработки CBM RICH на протяжении 3 (4) лет.

Задача создания и поддержания актуальной MC-модели поручается ответственному человеку, владеющему CATIA, GEANT/ROOT и ``CATIA-GDML geometry builder''. В зависимости от того, какая информация и в каких файлах имеется к началу работы, алгоритм немного различается. Если разработка ведётся в нуля и нет никаких данных в ЭВМ, что возможно, например, когда проект находится на таком этапе, когда нужно выполнить грубое моделирование, показывающее принципиальную возможность реализации, то наиболее оптимальный способ --- сразу строить MC-модель в CATIA средствами ``Builder''. Если, скажем, проект находится на раннем этапе разработки и уже имеется какая-то приблизительная САПР модель, то рекомендуется импортировать её стандартными средствами CATIA, чтобы затем на её основе построить MC-модель в CATIA в автоматизированном режиме с помощью средств ``Builder''. Инженерную геометрию можно импортировать практически из любой САПР, например с помощью широко распространённого формата STEP. Третий распространённый случай это когда уже имеется некоторая MC-модель в конечной системе моделирования. Как в GEANT4, так и в ROOT имеется стандартная возможность экспортировать геометрию в GDML файл без потери информации. Эту возможность могут наследовать все дочерние пакеты (как FairRoot и далее CbmRoot), но для этого необходимо явно активировать функциональность GDML. В этом случае можно импортировать модель в CATIA в MC-формате, однако иногда требуются некоторые дополнительные ручные операции после импорта. Они выполняются однократно и лишь делают структуру документа более оптимальной, но не изменяют геометрию.

Во всех этих алгоритмах, независимо от типа и количества исходных данных, получаются файлы CATIA в формате ``Builder'', которые в дальнейшем будут являться основными (первичными) файлами для получения рабочей MC-модели в экспериментальном пакете, которым в случае CBM RICH является CbmRoot. Модель из CATIA экспортируется в GDML файл, который не требует каких-либо последующих изменений в структуре. Для достижения этого условия была проведена огромная работа по мере разработки MC-модели CBM RICH. Допускается и даже рекомендуется текстовое редактирование GDML файла, но только для изменения значений параметров в define секции у параметризованных моделей. Затем, по желанию коллаборации, GDML файл может быть конвертирован в бинарный ROOT-файл, который содержит геометрию, которую невозможно редактировать. Это защищает модель от случайных изменений, что особенно актуально в случае параметризованных моделей. Соответственно, если требуется изменить значения параметров, пользователь может отредактировать GDML файл и экспортировать в новый ROOT файл. Практика показывает, что в случае, если требуется множество файлов с MC-геометрией, то обязательно нужно писать комментарии --- либо в самом GDML файле, либо в текстовом файле рядом с GDML/ROOT файлом. Обычно в коллаборации вводят правила именования файлов.

\subsection{Примитивы в ``Builder''}\label{sec:Primitives}

%В принципе мотивация уже обсуждалась в секции выше.
Примитив можно построить стандартными средствами САПР, используя эскизы и формообразования, но в таком случае конвертер не сможет автоматически определить, является ли построенная форма примитивом и, если да, определить параметры примитива. По этой причине был разработан принцип хранения формы примитива в MC-модели с помощью средства CATIA~v5, называемого User-Defined Feature (UDF), и средства для автоматизации создания примитивов --- макросы \macroname{AddShape} и \macroname{Poly}. Каждый примитив реализован в своём файле типа CATPart, в котором создаётся описание UDF, превращая этот файл в шаблон. Некоторые объекты модели, в случае примитивов --- некоторые стандартные плоскости, и параметры модели объявляются <<внешними>>. Далее в другом документе возможно создать вхождение формы, определённой в файле-шаблоне, вызвав соответствующее формообразование. При этом в текущем документе потребуется лишь выбрать необходимые элементы, с которыми будут совпадать <<внешние>> объекты шаблона, и задать значения параметрам создаваемого вхождения. Примитивы в ``Builder'' построены так, чтобы этими совпадающими элементами были стандартные плоскости. В этом случае при создании вхождения достаточно нажать кнопку use identical names и CATIA автоматически совместит правильные элементы. Более того, использование макроса \macroname{AddNewPart} автоматизирует этот процесс.

\subsection{Булевы операции}\label{sec:Boolean}

Форма объёма может быть задана как примитив либо Булева операция над примитивами или результатами Булевых операций, причём работает такое правило, что первый операнд каждой операции не должен подвергаться каким-либо преобразованиям координат. При создании Булевых операции матрица позиционирования второго операнда относительно первого задаётся трёмя поворотами вокруг стандартных фиксированных осей и одинм сдвигом --- также, как и при позиционировании дочернего объёма в материнском. Разница заключается в том, что порядок поворотов обратный --- сначала вокруг X, затем вокруг Y и вокруг Z. Сдвиг выполняется после поворотов.

Определено три Булевы операции (gприведены оригинальные названия в GEANT/ROOT и соответствующие названия в CATIA~v5):

\begin{itemize}
\item{Объединение (Union, Add);}
\item{Вычитание (Subtraction, Remove);}
\item{Пересечение (Intersection, Intersect).}
\end{itemize}

\subsection{Макропрограммы для CATIA~v5}\label{sec:Macros}

Макропрограммы для CATIA~v5 написаны на VBA с применением CATIA API. Все макропрограммы, кроме \macroname{AddShape} и \macroname{Poly}, доступны пользователю в режиме работы над сборкой. В CATIA различают открытый документ (верхний в дереве в текущем окне), активный документ (синий), выделенный объект (оранжевый) и рабочий объект (подчёркнутый). Пользователь может выполнить все операции, необходимые для получения MC-модели, самостоятельно без применения макропрограмм, но в этом случае велика вероятность упустить какой-либо шаг, что приведёт к ошибке, которую сложно диагностировать.

В MC-модели в CATIA есть строгие правила именования. Применение макросов избавляет пользователя от необходимости контролировать имена объектов в документах. Все имена, сгенерированные при использовании ``Buider'' не конфликтуют между собой и позволяют получить корректный GDML файл на выходе. Практически везде пользователь имеет право изменять суффиксы, не изменяя основного названия, несущего информацию о типе объекта --- формообразования, тела, и т.д. Однако в редких случаях суффикс имеет решающее значение, как например в именах поворотах (напр, ``Rotate.X'') суффикс несёт информацию о оси поворота.

В процессе разработки ``Builder'' был выработан стандартный алгоритм создания геометрии. Первый шаг --- создание нового документа типа CATProduct, который в дальнейшем будет единственным продуктом, и его сохранение на диск. Этот продукт будет представлять модель всей экспериментальной установки. Второй этап --- наполнение продукта описанием объёмов без описания взаимосвязей между ними. Для этого используется макрос \macroname{AddNewPart}, который автоматически открывает в отдельном окне новый документ типа CATPart, сформированный из специального шаблона и соответствующий создаваемому объёму. Система переходит в режим редактирования детали, где доступны только два макроса \macroname{AddShape} и \macroname{Poly} для создания формы объёма. Здесь же можно и задать имя материала объёма. По окончании редактирования нового объёма в отдельном окне пользователь должен сохранить активный документ и закрыть это окно. CATIA при этом возвращается к редактированию продукта. После того, как созданы объёмы, заданы формы и, возможно, имена материалов, алгоритм подразумевает задание иерархии объёмов, то есть позиционирование одних объёмов в других. Для этого в ``Builder'' существует целый ряд макропрограмм для создания различных типов взаимосвязей --- \macroname{Inserter}, \macroname{ArrayMaker}, \macroname{Replica}. После того, как выполнено размещение дочернего объёма $A$ в материнском объёме $B$, пользователь может указать поворот и сдвиг, задающие матрицу позиционирования $A$ в $B$. Для упрощения расчётов в некоторых случаях очень удобно применять макропрограммы \macroname{PointToPointAligner} (\macroname{Pt2PtAligner}), \macroname{Mover} и \macroname{Measure}. Для удобного редактирования материалов всех объёмов был разработан менеджер материалов \macroname{MaterialsManager}, который обычно имеет смысл вызывать перед экспортом для проверки ранее заданных имён материалов, либо назначения новых. Также перед экспортом рекомендуется проверить модель на наличие ошибок с помощью макроса \macroname{Checker}. В конце выполняется экспорт макросом \macroname{CATIA2GDML}. Отдельно стоят макропрограммы \macroname{Duplicator} для создания множественных идентичных, но не связанных, параметризованных подсборок и обратный конвертер \macroname{GDML2CATIA} для импорта GDML файла.

Для комфортной работы с ``Builder'' в поставке также имеются файлы для настройки окружения CATIA. Использования окружения в принципе не обязательно, но часть функционала зависит от путей к файлам, которые прописаны в переменных окружения, поэтому настоятельно рекомендуется перед использованием ``Builder'' выполнить настройку, следуя инструкции, поставляемой в пакете.

\subsubsection{AddNewPart}\label{sec:AddNewPart}

Данная макропрограмма автоматизирует создание нового документа типа CATPart на основе шаблона, содержащего необходимые элементы --- публикация главного тела детали, называемая PartBody, пользовательский параметр под названием Material со значением по умолчанию vacuum. Для удобства работы в файле шаблона и во всех генерируемых новый документах типа CATPart погашены стандартные плоскости. Созданный документ автоматически сохраняется на диск в папку, в которой выполняется построение модели, и которая автоматически определяется из открытого документа типа CATProduct в момент вызова макроса. Путь можно изменить в окне графического интерфейса. Также созданная деталь добавляется в качестве компонента в открытую сборку. Новый документ открывается в дочернем окне CATIA и пользователь может как начать работу над объёмом, так и оставить его пустым и отложить редактирование. Достаточно закрыть это окно и система перейдёт обратно к редактированию сборки.

\subsubsection{AddShape}\label{sec:AddShape}

\macroname{AddShape} используется для создания примитивов, в случае необходимости вместе с поворотами и сдвигом. Макропрограмма играет роль интерфейса между пользователем и файлами примитивов. При запуске макроса выводится окно со списком доступных примитивов, по нажатии на кнопку ``создать'' в рабочее тело детали вставляется выбранный примитив со значениями параметров по умолчанию. Если на форме графического интерфейса выбраны флаги создания поворотов и сдвига, то создаются соответствующие формообразования. Если форма объёма состоит из одного примитива, то повороты и смещение запрещены. Они имеют смысл только при содании второго операнда Булевой операции. Список примитивов формируется \todo проверить! \todo из списка файлов, имеющихся в папке примитивов, определённой с помощью относительного пути в BuilderPath.

\subsubsection{Poly}\label{sec:Poly}

В силу ограничений CATIA нет возможности представить полипримитивы (polycone и polyhedra) с помощью тех же средств, что и остальные примитивы, поэтому для них была разработана специальная структура дерева и правила именования. Для автоматизации построения полипримитивов в соответствии с этой структурой предоставляется макрос \macroname{Poly}. Секции поликонуса представлены стандартными конусами. В случае polyhedra для представления секции используется hedra --- специальный примитив, не поддерживаемый GEANT/ROOT.

\subsubsection{Inserter}\label{sec:Inserter}

Макрос \macroname{Inserter} --- это инструмент для помещения одного выбранного объёма в другой. Также можно сказать, что \macroname{Inserter} создаёт физический объём, задающий связь материнский-дочерний между двумя существующими логическими объёмами. \macroname{Inserter} --- возможно, самый используемый макрос, в результате работы которого в документе типа CATPart, представляющем материнский объём, создётся тело с именем ``Body.B.*'', где $B$ --- имя дочернего объёма. Внутри этого тела имеется ссылка на публикацию PartBody документа типа CATPart, представляющего объём $B$, и элементы преобразования типа Rotate и Translate --- три поворота и сдвиг, задающие матрицу позиционирования $B$ внутри $A$. Повороты выполняются вокруг фиксированных стандартных осей, а порядок строго определён --- сначала вокрус оси Z, затем вокрус оси Y и в конце вокрус оси X. Следует отметить, что такие повороты не являются преобразованиями Эйлера, где система кординат вращается вместе с телом и оси меняют своё направление.

\subsubsection{ArrayMaker}\label{sec:ArrayMaker}

%Надо вообще где-то сказать, что в кате есть массив, который конвертируется в независимые вхождения.

Макрос \macroname{ArrayMaker} схож с \macroname{Inserter} по идее и реализации. После выполнения вставки дочернего объёма в материнский, к созданному телу добавляется формообразование pattern вдоль указанной оси и с указанными шагом и количеством вхождений.

\subsubsection{Replica}\label{sec:Replica}

Одна из продвинутых возможностей геометрической подсистемы GEANT/ROOT --- это деление объёмов. В GEANT4 эта возможность называется replica, а в ROOT --- division. Суть заключается в том, что допускается деление некоторого объёма путём разрезания через равные промежутки вдоль одной из четырёх осей --- X, Y, Z и $\phi$, где $\phi$ --- круговое направление. В результате деления получается набор одинаковых под-объёмов --- долек, которые можно рассматривать как независимые вхождения одного объёма и позиционировать внутри другие объёмы. Отличие дольки от обычного объёма заключается в том, что для долек оптимизирована реализация проведения частиц. (\todo сформулировать лучше) Деление возможно только для ограниченного числа форм, таких, что все доли имеют одинаковую форму. Box --- в любом из трёх линейных направлений X, Y или Z. Tubs --- вдоль оси цилиндра, то есть вдоль линейной оси Z, или вдоль круговой оси $\phi$. Дальше продолжать\todo 

За счёт того ограничения, что формы долек должны быть одинаковы, для описания разделённых объёмов в CATIA решено использовать тот же принцип, что и для описания массивов с тем отличием, что имя формообразования pattern должно соответствовать шаблону ``Replica.Axis'', где Axis --- ось реплицирования. За счёт того ограничения, что дольки должны заполнять всё пространство материнского объёма возможен автоматический расчёт геометрических размеров дольки по двум входным параметрам --- направлению деления и количеству.

\subsubsection{PointToPointAligner}\label{sec:PointToPointAligner}

\macroname{PointToPointAligner} автоматизирует процесс позиционирования дочернего объёма внутри материнского. При вложении одного объёма в другой необходимо задать положение дочернего объёма в материнском. В ``Builder'' для этого используется три формообразования типа Rotate --- последовательные повороты вокруг трёх фиксированных стандартных осей Z, Y и X --- и одно типа Translate --- параллельный сдвиг. Пользователь должен каким-то образом рассчитать значения углов и координаты сдвига. Типовая процедура определения этих значений заключается в том, что пользователь использует стандартные средства CATIA для измерения углов и расстояний и затем вручную записывает эти значения в соответствующие параметры. В случае сложного поворота практически невозможно получить углы поворота прямым измерением, требуется активное интеллектуальное участие пользователя. Определение смещения, которое выполняется после всех поворотов, прямолинейно, но требует выполнения достаточно большого количества механических операций, которые автоматизированы в \macroname{PointToPointAligner}.

Этот макрос предоставляет пользователю возможность выбрать две точки, которые совместятся придвижением первой ко второй. Первая точка должна быть вершиной, принадлежащей телу, обозначающему дочерний объём --- только в этом случае в макропрограмме представляется возможным определить, какому телу принадлежит выбранная вершина, чтобы выбрать формообразования, описывающие матрицу позиционирования, которую необходимо изменить. Вторая точка может быть полученной в результате любой операции --- это может быть как вершина тела, так и каркасный элемент. Для неё определяются только координаты, чтобы рассчитать сдвиг как разность координат двух точек.

\subsubsection{Mover}\label{sec:Mover}

Нередко возникает такая ситуация, что требуется подвинуть группу дочерних объёмов внутри одного материнского на одинаковое расстояние. Если использовать существующие средства CATIA, то нет никакого способа выполнить этот сдвиг для нескольких объёмов сразу. В ручном режиме пользователю требуется осуществлять сдвиг для каждого объёма отдельно путём изменения значений параметров формообразования Transltate, отвечающего за позиционирование дочернего объёма в материнском. Чтобы автоматизировать этот процесс был разработан \macroname{Mover}. При использовании \macroname{Mover} пользователь выбирает какие дочерние объёмы он хочет подвинуть и на какое расстояние в графическом интерфейсе.

\subsubsection{Measure}\label{sec:Measure}

Макропрограмма \macroname{Measure} автоматизирует процесс измерения и записи результата измерения в какой-либо параметр модели. Необходимость выполнения подобной операции особенно часто возникает при работе одновременно с исходной САПР моделью и разрабатываемой MC-моделью. Если требуется измерить какое-либо расстояние между объектами или размер какого-либо геометрического элемента, то пользователь может воспользоваться стандартными средствами CATIA ``Measure between'' и ``Measure item'' соответственно. В результате появляется окно с результатами измерения, обычно включая компоненты по координатам. Чтобы перенести эти результаты измерения куда-либо необходимо выделить и скопировать значение из поля, закрыть окно измерения, найти параметр в MC-модели, открыть его для редактирования и вставить в качестве значения содержимое буфера обмена. При использовании \macroname{Measure} список параметров модели отображается в окне графического интерфейса. Пользователь сначала выбирает тип измерения, затем выбирает измеряемые объекты в области геометрии. Результаты измерения выводятся в окне графического интерфейса и для того, чтобы записать выбранный результат в какой-либо параметр MC-модели, достаточно выбрать его в списке параметров.

\subsubsection{MaterialsManager}\label{sec:MaterialsManager}

Приложение \macroname{MaterialsManager} предоставляет пользователю возможность изменять материалы отдельных объёмов, находясь на уровне верхнего продукта. Это избавляет от необходимости часто переключаться между документами либо режимами работы в случае контекстного редактирования. Также заметным преимуществом использования \macroname{MaterialsManager} является наглядность --- информация о материалах всех объемов представляется в компактном списке, присутствует возможность быстро изменять значения в нескольких элементах списка. Помимо этого, наличие \macroname{MaterialsManager} позволяет отложить работу с материалами на последний этап. Использование шаблона файла детали предотвращает от того, что пользователь вообще не укажет материал объема --- по умолчанию указан вакуум (vacuum). В графическом интерфейсе \macroname{MaterialsManager} представлена таблица из трёх столбцов --- имя документа (объём), текущий материал, новый материал. Все изменения применяются только к этому списку до тех пор, пока пользователь не нажмёт кнопку Apply changes \todo и изменения не внесутся в соответствующие документы типа CATPart.

\subsubsection{Checker}\label{sec:Checker}

Чтобы ускорить процесс моделирования необходимо отлавливать ошибки на как можно более раннем этапе. Макрос \macroname{Checker} позволяет выполнять проверку правильности построенной пользователем MC-модели в CATIA до экспорта в GDML, таким образом сокращая время отладки, которое ушло бы на экспорт геометрии в GDML, импорт в GEANT/ROOT и запуск проверки в конечной системе. Необходимость проверки возникает в силу того, что в разработанной структуре документов CATIA для MC-модели введено множество правил и ограничений, нетипичных для \todo conventional использования системы. \macroname{Checker} выполняет 2 типа проверок. Первый --- корректность с точки зрения конвертера, т.е. соблюдение структуры документов, правильность именования, второй --- корректность с точки зрения правил построения геометрии в GEANT/ROOT.

Использование разработанных интерактивных приложений ограждает пользователя от ошибок именования в итоговой MC-модели. Есть только одно место, где необходимо вручную указывать имя --- формообразование-вращение при позиционировании операнда на уровне формы (\todo уточнить). В любом случае, пользователь в праве редактировать модель не применяя макросы --- это ускоряет процесс в некоторых случаях, но повышает вероятность нарушения правил именования. Принципиальные ошибки в структуре документов MC-модели с большой долей вероятности приведут к некорректному завершению \macroname{Checker}, потому что практически невозможно автоматически их проверять.

Корректность геометрии определяется по двум критериям:
\begin{enumerate}
\item любые два объёма, находящиеся на одном уровне, не должны пересекаться;
\item любой дочерний объём не должен выходить за пределы материнского объёма.
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{pictures/Checker.eps}
\caption{Логические операции для определения правильности позиционирования объёмов.}
\label{fig:CheckerOperations}
\end{figure}

Чтобы организовать проверку указанных условий, разработан специальный алгоритм и реализован в виде отдельной макропрограммы \macroname{Checker} САПР CATIA. В цикле перебираются все пары объёмов, лежащих на одном уровне, и проверяется, не пусто ли множество пересечения текущей пары. В том случае, если не пусто, то возникает событие, оповещающее, что текущая пара объёмов расположена недопустимым образом.

Более детально описанный процесс выглядит следующим образом. В силу того, что физические объёмы описываются телами детали, перебор объёмов, лежащих на одном уровне, сводится к перебору всех тел детали, кроме PartBody. Чтобы исследовать множество пересечения пары тел, создаётся новое пустое тело и копии исходных. Затем применяется Булева операция Intersect над копиями, и результат заносится в ранее созданное пустое тело. На этапе выполнения формообразования булевой операции выдаётся возможность отследить корректность результата. С точки зрения CATIA пустое пересечение является ошибочным результатом и возникает внутренняя ошибка. Именно программный отлов и обработка этой ошибки говорит о корректности расположения объёмов. После выполнения булевой операции результирующее тело удаляется, не оставляя таким образом никаких следов промежуточных преобразований.

Для того чтобы отследить, не выходит ли объём за пределы материнского объёма, применяется схожий подход. Отличие заключается в последовательности булевых операций --- вместо пересечения $A*B$ двух объёмов $A$ и $B$ проверяется объём, полученный последовательностью двух операций $(A+B)-A$, где $A$ --- материнский объём, а $B$ --- дочерний. Присутствие результата операции $(A+B)-A$ говорит о том, что какая-либо часть дочернего объёма расположена за пределами материнского.

\subsubsection{CATIA2GDML}\label{sec:CATIA2GDML}

Конвертер \macroname{CATIA2GDML} проецирует дерево потроения MC-модели из CATIA~v5 в GDML файл. За счёт того, что правила построения MC-модели в CATIA формулировались с ориентиром на структуру, принятую в GEANT/ROOT, базовый функционал прямого конвертера заключается в том, что он создаёт в выходном GDML файле сущности, соответствующие найденным объектам в дереве построения в CATIA. Важной особенностью является то, что конвертер не обращается к самой геометрии, вся необходимая информацию содержится в дереве построение модели.

Помимо прямолинейного отображения дерева модели в GDML, в \macroname{CATIA2GDML} осуществляется преобразование некоторых особенностей, введённых в CATIA для упрощения процесса моделирования. Так, например, для отображения массива (см. \ref{} \todo), которого нет в возможностях GDML, макрос рассчитывает повороты и положения каждого вхождения и создаёт независимые дочерние объёмы в GDML. В случае линейный массивов задача проста. Описание \todo В случае круговых массивов расчёт выполняется с применением матричных преобразований, обсуждаемых в~\ref{sec:Matrices}.

В дереве CATIA нет обособленного списка используемых в модели материалов, поэтому для создания такого в GDML выполняется нехитрый алгоритм, который при проходе в цикле по объёмам добавляет в выходной список имя материала, если такого ещё нет.

% Цвет
В ``Builder'' реализована возможность переноса цвета объёма с помощью вспомогательного тега auxilliary в GDML файле, который позволяет добавлять произвольное поле данных к описанию логического объёма. Цвет тела в CATIA никак не отображается в дереве, поэтому для формирования тега при экспорте модели опрашиваются параметры вызуализации главного тела PartBody детали, содержащие в том числе и цвет.

\subsubsection{GDML2CATIA}\label{sec:GDML2CATIA}

\macroname{GDML2CATIA} выполняет процедуру, обратную \macroname{CATIA2GDML} --- проецирует GDML файл на дерево модели CATIA~v5. В ``Builder'' есть возможность задавать линейные и круговые массивы --- многократные вхождения дочернего объёма в материнский, позиционированные с некоторым шагом вдоль линейной или круговой оси соответственно. В MC-модели в CATIA для массивов применяется соответствующее стандартное формообразование pattern. Такая возможность отсутствует в GDML, поэтому при экспорте из CATIA в GDML выполняется расчёт поворотов и сдвигов для каждого элемента массива и они представляются как отдельные, независимые дочерние объёмы. Таким образом при конвертации в обратном направлении, из GDML в CATIA, невозможно восстановить массив. Следовательно, одна из немногих (единственная \todo) операций, которые необходимо совершать после импорта геометрии из GDML в CATIA --- ручной перевод множества дочерних объёмов в массив. Обычно это очень простая процедура, и заключается она в том, что удаляются все вхождения, кроме первого, и в список формообразований первого тела добаляется pattern, которому задаются необходимые параметры и имя.

% Цвет
Аналогично прямому конвертеру, для передачи цвета автоматически выполняется дополнительная операция присвоения параметров визуализации тела если в GDML встречается тэг auxilliary.

\subsubsection{Параметризация}\label{sec:Parameterization}

Одна из наиболее важных возможностей ``CATIA-GDML geometry builder'' --- это возможность создания параметризованных геометрических MC-моделей. У параметризованной модели имеются входные параметры и формулы, задающие зависимость между этими входными параметрами и внутренними переменными, такими как параметры примитивов, значения поворотов и смещений. Данная концепция хорошо ложится на методы работы с геометрией в САПР, особенно CATIA~v5. Также параметризация поддерживается форматом GDML и импортёрами GEANT4(\todo) и ROOT.

В модели CATIA~v5 можно вводить пользовательские параметры как в документах типа CATProduct, так и в документах типа CATPart. Причём сборка в CATProduct файле может иметь свои пользовательские параметры и формулы, а дочерние компоненты в CATPart файлах --- свои. Обязательное требование ``Builder'' таково, что все параметры и формулы должны находиться в верхнем продукте. CATIA~v5 позволяет задавать зависимости между любыми параметрами, в том числе внутренними, не являющимися пользовательскими, однако для успешного экспорта в GDML файл формула должна в левой части иметь параметр примитива или угол поворота или значение сдвига, а в правой части --- формулу только над пользовательскими параметрами. Пользовательский параметр CATIA~v5, экспортируемый в переменную в GDML должен обязательно иметь безразмерный тип Real. В связи с этим имеются правила оформления формул и приведения единиц измерения. Также имеется стандартная переменная DEGtoRAD для перевода значения углов из градусов в радианы.

На выходе получается GDML файл, у которого в define секции есть тэги variable, обозначающие входные параметры модели со значениями. При импорте параметризованной геометрии из GDML в ROOT все значения внутренних переменных рассчитываются в соответствии с формулами по значениям входных параметров и параметризация теряется. Следовательно значения входных параметров должны задаваться пользователем непосредственно в GDML файле перед импортом в конечную систему.

\subsubsection{Duplicator}\label{sec:Duplicator}

Создание MC-модели более-менее сложной экспериментальной установки обычно требует создания нескольких вхождений параметризованных подборок с разными значениями параметров. Можно привести следующий пример. Рассмотрим детектор, состоящий из однотипных модулей, содержащих массив чувствительных объёмов (сенсоров), и какие-то другие элементы, например, платы передней электроники. Предположим, что существует несколько типоразмеров модулей, отличающихся количеством и размером сенсоров. Таким детектором может быть, например, калориметр, построенный из нескольких типов модулей, отличающихся гранулярностью --- размер чувствительного объёма увеличивается по мере удаления от пучка. Очевидно, что если типы модулей отличаются лишь значениями каких-либо переменных, то представляется возможным построить одну параметризованную модель модуля, чтобы дальше использовать её многократно для построения всего детектора. К сожалению в GEANT/ROOT нет возможности так сделать --- нужно для каждого типа иметь отдельное определение геометрии. Также это невозможно и в GDML и в CATIA.

В модели для каждой комбинации параметров, то есть для каждого модуля в нашем примере, должна существовать отдельная параметризированная подсборка. При этом имена всех объёмов должны отличаться, а наборы параметров для каждого модуля должны быть независимы. В CATIA нет возможности быстро создать копию подсборки вместе со всеми параметрами и зависимостями.

Для того, чтобы атоматизировать процесс создания такой копии используется \macroname{Duplicator}.
Работа с \macroname{Duplicator} выполняется в 2 этапа.

\todo

\subsubsection{Визуализация нескольких уровней вложенности объёмов}\label{sec:MultiLevelVis}

\todo

\subsubsection{Переменные окружения}\label{sec:BuilderEnv}

Для максимального сокрытия подробностей реализации от пользователей и минимизации их действий, ``CATIA-GDML geometry builder'' использует возможности CATIA~v5 по настройке окружения. Пакет поставляется с папкой CATSettings, которая должна быть указана как папка с настройками при конфигурировании окружения перед началом использования пакета. Инструкция по настройке поставлется вместе с ``Builder''. В настройках окружения помимо прочего определены переменные окружения, значения которых активно используются из кода макропрограмм. В первую очередь неоходимо задать переменную BuilderPath, в которой необходимо указать путь к папке с ``Builder'', полученной тем или иным способом. Помимо того, что без BuilderPath не будут работать некоторые макропрограммы, не будет работать и пользовательские панели инструментов ``CATIA-GDML geometry builder'' в CATIA. \todo проверить

\subsection{Избранные подробности реализации ``CATIA-GDML geometry builder''}

Каждый макрос ``Builder'' --- это VBA проект, который хранится в отдельном catvba файле. Проект состоит из трёх разделов --- элементы графического интерфейса (формы), модули и модули классов. Большинство макросов ``Builder'' написано в соответствии с идеологией структурного программирования, без применения классов, и разделение на модули выполнено из соображений читаемости кода. Обычно в отдельный модуль выносился функционал, объединённый некоторой задачей. Так, например, во многих макросах имеется модуль \todo (имя) для продвинутой работы со строками, модуль \todo (имя) для \todo (задача). В некоторых случаях естественным образом требовалось использовать классы. Так, например, был реализован класс матрицы с методами нахождения углов поворота, который использовался в \todo и более подробно описан в~\ref{sec:Matrices}.

\subsubsection{Работа с матрицами позиционирования в ``CATIA-GDML geometry builder''}\label{sec:Matrices}
