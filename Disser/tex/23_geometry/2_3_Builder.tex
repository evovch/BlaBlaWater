% ================================================================================================================
%
% ________/\\\\\\\\\_____/\\\\\\\\\_____/\\\\\\\\\\\\\\\__/\\\\\\\\\\\_____/\\\\\\\\\__________________        
%  _____/\\\////////____/\\\\\\\\\\\\\__\///////\\\/////__\/////\\\///____/\\\\\\\\\\\\\________________       
%   ___/\\\/____________/\\\/////////\\\_______\/\\\___________\/\\\______/\\\/////////\\\_______________      
%    __/\\\_____________\/\\\_______\/\\\_______\/\\\___________\/\\\_____\/\\\_______\/\\\__/\\\\\\\\\\\_     
%     _\/\\\_____________\/\\\\\\\\\\\\\\\_______\/\\\___________\/\\\_____\/\\\\\\\\\\\\\\\_\///////////__    
%      _\//\\\____________\/\\\/////////\\\_______\/\\\___________\/\\\_____\/\\\/////////\\\_______________   
%       __\///\\\__________\/\\\_______\/\\\_______\/\\\___________\/\\\_____\/\\\_______\/\\\_______________  
%        ____\////\\\\\\\\\_\/\\\_______\/\\\_______\/\\\________/\\\\\\\\\\\_\/\\\_______\/\\\_______________ 
%         _______\/////////__\///________\///________\///________\///////////__\///________\///________________
%
% _____/\\\\\\\\\\\\__/\\\\\\\\\\\\_____/\\\\____________/\\\\__/\\\_____________        
%  ___/\\\//////////__\/\\\////////\\\__\/\\\\\\________/\\\\\\_\/\\\_____________       
%   __/\\\_____________\/\\\______\//\\\_\/\\\//\\\____/\\\//\\\_\/\\\_____________      
%    _\/\\\____/\\\\\\\_\/\\\_______\/\\\_\/\\\\///\\\/\\\/_\/\\\_\/\\\_____________     
%     _\/\\\___\/////\\\_\/\\\_______\/\\\_\/\\\__\///\\\/___\/\\\_\/\\\_____________    
%      _\/\\\_______\/\\\_\/\\\_______\/\\\_\/\\\____\///_____\/\\\_\/\\\_____________   
%       _\/\\\_______\/\\\_\/\\\_______/\\\__\/\\\_____________\/\\\_\/\\\_____________  
%        _\//\\\\\\\\\\\\/__\/\\\\\\\\\\\\/___\/\\\_____________\/\\\_\/\\\\\\\\\\\\\\\_ 
%         __\////////////____\////////////_____\///______________\///__\///////////////__
%
% ________________________________________________________________________________________________________________________        
%  ________________________________________________________________________________________________________________________       
%   ___/\\\\\\\\______________________________________________________________________/\\\_______________________/\\\__/\\\_      
%    __/\\\////\\\_____/\\\\\\\\______/\\\\\_______/\\\\\__/\\\\\_______/\\\\\\\\___/\\\\\\\\\\\__/\\/\\\\\\\____\//\\\/\\\__     
%     _\//\\\\\\\\\___/\\\/////\\\___/\\\///\\\___/\\\///\\\\\///\\\___/\\\/////\\\_\////\\\////__\/\\\/////\\\____\//\\\\\___    
%      __\///////\\\__/\\\\\\\\\\\___/\\\__\//\\\_\/\\\_\//\\\__\/\\\__/\\\\\\\\\\\_____\/\\\______\/\\\___\///______\//\\\____   
%       __/\\_____\\\_\//\\///////___\//\\\__/\\\__\/\\\__\/\\\__\/\\\_\//\\///////______\/\\\_/\\__\/\\\__________/\\_/\\\_____  
%        _\//\\\\\\\\___\//\\\\\\\\\\__\///\\\\\/___\/\\\__\/\\\__\/\\\__\//\\\\\\\\\\____\//\\\\\___\/\\\_________\//\\\\/______ 
%         __\////////_____\//////////_____\/////_____\///___\///___\///____\//////////______\/////____\///___________\////________
%
% __/\\\_____________________________/\\\\\\____________/\\\_______________________________        
%  _\/\\\____________________________\////\\\___________\/\\\_______________________________       
%   _\/\\\_______________________/\\\____\/\\\___________\/\\\_______________________________      
%    _\/\\\_________/\\\____/\\\_\///_____\/\\\___________\/\\\______/\\\\\\\\___/\\/\\\\\\\__     
%     _\/\\\\\\\\\__\/\\\___\/\\\__/\\\____\/\\\______/\\\\\\\\\____/\\\/////\\\_\/\\\/////\\\_    
%      _\/\\\////\\\_\/\\\___\/\\\_\/\\\____\/\\\_____/\\\////\\\___/\\\\\\\\\\\__\/\\\___\///__   
%       _\/\\\__\/\\\_\/\\\___\/\\\_\/\\\____\/\\\____\/\\\__\/\\\__\//\\///////___\/\\\_________  
%        _\/\\\\\\\\\__\//\\\\\\\\\__\/\\\__/\\\\\\\\\_\//\\\\\\\/\\__\//\\\\\\\\\\_\/\\\_________ 
%         _\/////////____\/////////___\///__\/////////___\///////\//____\//////////__\///__________
%
% ================================================================================================================

\section{Инструментарий ``CATIA-GDML geometry builder''}\label{sec:secBuilder}

``CATIA-GDML geometry builder'' (далее просто ``Builder'') представляет собой набор документов-шаблонов и макропрограмм для САПР CATIA~v5 вместе с настройками окружения и инструкциями к применению стандартных средств CATIA~v5. ``Builder'' ставит своей задачей упростить процесс создания CSG моделей с иерархией объёмов, напрямую совместимых с GEANT/ROOT.

Центральная идея ``Builder'' заключается в правилах соответствия сущностей CATIA~v5 и сущностей геометрии в GEANT/ROOT. Это соответствие делает возможным конвертацию MC-модели в CATIA~v5 в любой внешний файл с целью дальнейшего импорта в ROOT/GEANT. В качестве формата для обмена был выбран XML-подобный формат GDML (geometry description markup language), разработанный в CERN, для которого в GEANT4 и ROOT реализованы методы импорта и экспорта.

Вся геометрия установки создаётся в одном документе типа CATProduct. Объёму соответствует деталь, хранящаяся в файле типа CATPart. Форме соответствует главное тело детали, по умолчанию называемое PartBody. В CATIA не записывается описание материала так, как это принято в GEANT/ROOT, а сохраняется только имя материала в пользовательском параметре Material. Это возможно по той причине, что существует практика хранить описание материалов во внешнем файле или базе данных, считывать его перед выполнением моделирования и приписывать объёмам в соответствии с именами. Для обозначения физического объёма $B$ внутри $A$ в структуре документа, описывающего объём $A$, создаются тела Body.B.*, где * по умолчанию обозначает номер вхождения, но допускается запись любой идентифицирующей строки.

\textbf{Может быть частично перенести в описание методов описания геометрии в GEANT/ROOT.}
Также в ``Builder'' предусмотрена возможность задания геометрии некоторыми продвинутыми методами, специфичными для GEANT/ROOT. В GEANT/ROOT существует тип объёмов, называемый Asssembly, который характеризуется тем, что он не имеет формы и материала. Практически объём типа Assembly является контейнером без границ, который объединяет свои дочерние объёмы, что особенно удобно как минимум в двух случаях. Во-первых, если необходимо многократно позиционировать группу объёмов, которую невозможно охватить простой формой. Во-вторых, если преобразование координат при позиционировании одного или группы объёмов имеет сложную структуру и удобно представить его как суперпозицию двух преобразований. Как частный случай можно упомянуть ситуацию, когда какой-либо параметр преобразования является параметром модели (см. секцию~\ref{sec:Parameterization})

Один из плюсов ``Builder'' заключается в том, что пользователю предоставляется возможность работать с полноценной инженерной моделью и MC-моделью в одной и той же среде, имеющей широкие возможности для анализа и редактирования геометрии. ``Builder'' не ставит своей задачей перевод модели из одного геометрического представления в другой, но значительно ускоряет процесс создания одной геометрии, на основе другой. Также важно отметить, что подходы к геометрическому моделированию в САПР подразумевают широкое использование параметров --- практически все размеры, значения поворотов и сдвигов, количество вхождений в массивы и прочие числа, определяющие форму и структуру модели, могут подвергаться изменению на любом этапе. Если в процесе построения модели этот принцип параметризированного моделирования нарушается, САПР предупреждает пользователя перед выполнением операции, которая приведёт к разрыву связи с параметром. В CATIA~v5 при изменении каких-либо параметров геометрическая модель перестраивается интерактивно --- от долей секунды до нескольких секунд в зависимости от сложности модели.  Эта стандартная черта САПР очень удобна при работе с MC-моделями и отсутствует, например, в GEANT и ROOT.

``Builder'' включает в себя файлы, в которых специальным образом построены примитивы GEANT/ROOT, позволяющие пользователю при построении MC-модели не вникать в подробности реализации, а использовать их практически как и в процессе создания геометрии средствами ROOT или GEANT. ``Builder'' также включает в себя макропрограммы для CATIA~v5, которые также ставят своей задачей сделать процесс построения геометрии в ``Builder'' максимально похожим на процесс построения геометрии в GEANT или ROOT. Основной макрос --- это конвертер \macroname{CATIA2GDML}, который проецирует дерево построения модели в CATIA в GDML файл. Также разработан обратный конвертер \macroname{GDML2CATIA} для импорта GDML файлов.

Целевая аудитория ``CATIA-GDML geometry builder'' --- физики, владеющие CATIA~v5 на базовом уровне, и инженеры, продвинутые пользователи САПР, изучившие способ представления геометрии в GEANT/ROOT хотя бы на теоретическом уровне. \textbf{Есть опыт, который показывает, что для достижения такого уровня как физикам, так и инженерам, достаточно прохождения двухнедельного курса.}

Предлагается новый алгоритм работы, в котором ``Builder'' используется как многофункциональный инструмент. Описанный ниже алгоритм сформулирован на успешном опыте разработки CBM RICH на протяжении 3 (4) лет.

Задача создания и поддержания актуальной MC-модели поручается ответственному человеку, владеющему CATIA, GEANT/ROOT и ``CATIA-GDML geometry builder''. В зависимости от того, какая информация и в каких файлах имеется к началу работы, алгоритм немного различается.
% case 1
Если разработка ведётся в нуля и нет никаких данных в ЭВМ, что возможно, например, когда проект находится на таком этапе, когда нужно выполнить грубое моделирование, показывающее принципиальную возможность реализации, то наиболее оптимальный способ --- сразу строить MC-модель в CATIA средствами ``Builder'' (см. секцию~\ref{sec:secMCfromScratch}).
% case 2
Если, скажем, проект находится на раннем этапе разработки и уже имеется какая-то приблизительная САПР модель, то рекомендуется импортировать её стандартными средствами CATIA, чтобы затем на её основе построить MC-модель в CATIA в автоматизированном режиме с помощью средств ``Builder''. Более подробно этот случай описан в секции~\ref{sec:secMCfromCAD}.
% case 3
Третий распространённый случай это когда уже имеется некоторая MC-модель в конечной системе моделирования. В этом случае можно импортировать модель в CATIA в MC-формате, однако иногда требуются некоторые дополнительные ручные операции после импорта. Они выполняются однократно и лишь делают структуру документа более оптимальной, но не изменяют геометрию. Этот случай описан в секции~\ref{sec:secMCtoCAD}.

Во всех этих алгоритмах, независимо от типа и количества исходных данных, получаются файлы CATIA в формате ``Builder'', которые в дальнейшем будут являться основными (первичными) файлами для получения рабочей MC-модели в экспериментальном пакете, которым в случае CBM RICH является CbmRoot. Модель из CATIA экспортируется в GDML файл, который не требует каких-либо последующих изменений в структуре. Для достижения этого условия была проведена огромная работа по мере разработки MC-модели CBM RICH. Допускается и даже рекомендуется текстовое редактирование GDML файла, но только для изменения значений параметров в define секции у параметризованных моделей. Затем, по желанию коллаборации, GDML файл может быть конвертирован в бинарный ROOT-файл, который содержит геометрию, которую невозможно редактировать. Это защищает модель от случайных изменений, что особенно актуально в случае параметризованных моделей. Соответственно, если требуется изменить значения параметров, пользователь может отредактировать GDML файл и экспортировать в новый ROOT файл. Практика показывает, что в случае, если требуется множество файлов с MC-геометрией, то обязательно нужно писать комментарии --- либо в самом GDML файле, либо в текстовом файле рядом с GDML/ROOT файлом. Обычно в коллаборации вводят правила именования файлов.

% ================================================================================================================
%  ____            _                                                   
% |  _ \  ___  ___(_) __ _ _ __      _ __  _ __ ___   ___ ___  ___ ___ 
% | | | |/ _ \/ __| |/ _` | '_ \    | '_ \| '__/ _ \ / __/ _ \/ __/ __|
% | |_| |  __/\__ \ | (_| | | | |   | |_) | | | (_) | (_|  __/\__ \__ \
% |____/ \___||___/_|\__, |_| |_|   | .__/|_|  \___/ \___\___||___/___/
%                    |___/          |_|                                
% ================================================================================================================

\subsection{Поддержка MC-модели с помощью ``Builder'' на протяжении процесса проектирования детектора}\label{sec:DesignProcess}

Использование ``Builder'' для создания и поддержки MC-геометрии на этапе проектирования детектора имеет некоторые особенности. Инженерный проект изменяется и необходимо постоянно поддерживать соответствие MC-модели и САПР-модели. В процессе проектирования можно выделить два вида изменений --- радикальные перемены в структуре и уточнение существующих узлов. В первом случае нередко бывает удобно с нуля перестроить MC-модель, может быть используя некоторые созданные ранее подсборки. Тогда достаточно выделить повторно используемые файлы, описывающие некоторые объёмы, и вставить их в качестве компонентов в верхний документ типа CATProduct разрабатываемой новой геометрии. Если между документами существовала связь типа дочерний-материнский, то она нарушится, т.к. изменится контекст. Для восстановления достаточно выполнить операцию автоматического переопределения связей с помощью операции define contextual links.

В процессе уточнения геометрии иногда возникает необходимость вводить какие-то особенности, которые приводят к невозможности использовать принципы многократного позиционирования объёмов, такие как деление объёмов и массивы (\todo ссылки). Тогда приходится нарушать периодичность структуры, и следовательно краткость описания, и использовать независимые вхождения дочерних объёмов. 

В качестве примера можно привести фокусирующую систему CBM RICH, состоящую из 80~сегментов зеркал шести типов. Для наиболее эффективного описания подобной геометрии следует использовать деление объёма (см. секцию~\ref{sec:secMacroReplica} \todo может быть будет ссылка на секцию про реплику, но не макрос \todo), имеющего форму примитива типа ``сегмент сферы'', вдоль кругового направления. Известно, что если использовать деление объёмов, то получается геометрия, более оптимальная с точки зрения времени моделирования прохождения частиц. Исходя из этих соображений, на раннем этапе зеркала фокусирующей системы CBM RICH были созданы следующим образом. Каждое из двух зеркал состояло из трёх сегментов сферы, вытянутых вдоль горизонтальной оси, разделённых на 10~долей вдоль кругового направления, и ещё одной горизонтальной полосы, в которой отдельные сегменты зеркал вставлялись независимо. Дольки, полученные делением каждого из трёх сегментов сферы, соответствуют трём типам сегментов зеркал. В последней полосе, наиболее близкой к пучку, не было возможности также использовать деление объёма из-за наличия прорези для пучковой трубы. Это привело к тому, что помимо четвёртого типа сегментов зеркал, было введено два дополнительных типа сегментов зеркал, имеющих симметричную форму (см.~\figref{}).

При таком описании между сегментами зеркал отсутствуют зазоры. Они не были реализованы, т.к. на том этапе эта подробность не имела значения, однако присутствовала возможность легко их добавить введя один дополнительный уровень вложенности.

\textbf{Картинка.}

К какой-то момент по мере проработки проекта детектора были зафиксированы параметры зеркал --- радиус, количество и форма сегментов, угол наклона, положение центра, и т.д. Также возникла необходимость выполнять моделирование отклонения индивидуальных сегментов от идеального положения (см. секцию~\ref{sec:secRICHgeoMirrorMis}). Для такого моделирования пользователь должен иметь возможность для каждого сегмента задавать углы отклонения вокруг двух осей в локальной системе координат, индивидуальной для каждого отдельного сегмента. Это требование противоречит идее деления объёмов, где все дольки, полученные в результате деления, имеют одинаковую форму, расположены строго периодически вдоль заданного направления с некоторым шагом и полностью заполняют пространство разделяемого объёма. В случае деления вдоль кругового направления дольки отличаются углом поворота вокруг оси Z и невозможно  задать какое-либо дополнительное вращение каждой отдельной дольке. Таким образом, пришлось отказаться от использования деления объёмов и использовать независимое многократное позиционирование сегментов внутри объёма-контейнера.

% ================================================================================================================
%  ____       _           _ _   _                
% |  _ \ _ __(_)_ __ ___ (_) |_(_)_   _____  ___ 
% | |_) | '__| | '_ ` _ \| | __| \ \ / / _ \/ __|
% |  __/| |  | | | | | | | | |_| |\ V /  __/\__ \
% |_|   |_|  |_|_| |_| |_|_|\__|_| \_/ \___||___/
%                                                
% ================================================================================================================

\subsection{Примитивы в ``Builder''}\label{sec:Primitives}

%В принципе мотивация уже обсуждалась в секции выше.
Любой примитив можно построить стандартными средствами САПР, используя эскизы и формообразования, но в таком случае конвертер не сможет автоматически определить, является ли построенная форма примитивом и, если да, определить параметры примитива. По этой причине был разработан принцип хранения формы примитива в MC-модели с помощью средства CATIA~v5, называемого User-Defined Feature (UDF), и средства для автоматизации создания примитивов --- макросы \macroname{AddShape} и \macroname{Poly}. Каждый примитив реализован в своём файле типа CATPart, в котором создаётся описание UDF, превращая этот файл в шаблон. Некоторые объекты модели, в случае примитивов --- некоторые стандартные плоскости, и параметры модели объявляются <<внешними>>. Далее в другом документе возможно создать вхождение формы, определённой в файле-шаблоне, вызвав соответствующее формообразование. При этом в текущем документе потребуется лишь выбрать необходимые элементы, с которыми будут совпадать <<внешние>> объекты шаблона, и задать значения параметрам создаваемого вхождения. Примитивы в ``Builder'' построены так, чтобы этими совпадающими элементами были стандартные плоскости. За счёт этого при создании вхождения достаточно нажать кнопку use identical names и CATIA автоматически совместит правильные элементы. Более того, использование макроса \macroname{AddNewPart} автоматизирует этот процесс.

Из-за того, что полипримитивы polycone и polyhedra имеют переменное число секций, оказалось невозможным реализовать их так же как и остальные примитивы с помощью UDF. Чтобы представить полипримитив в дереве построения модели в CATIA используется последовательность чередующихся UDF, описывающих отдельные секции, и формообразований translate, необходимых для обеспечения сдвига секций относительно друг друга. В случае polycone секция моделируется стандартный примитивом cons (cone section), а для polyhedra аналогичной стандартной формы не существует, поэтому она была введена искусственно. Примитив hedra существует только в ``Builder'', он нужен для создания polyhedra и не можетбыть использован где-либо ещё.

% ================================================================================================================
%  ____              _                  
% | __ )  ___   ___ | | ___  __ _ _ __  
% |  _ \ / _ \ / _ \| |/ _ \/ _` | '_ \ 
% | |_) | (_) | (_) | |  __/ (_| | | | |
% |____/ \___/ \___/|_|\___|\__,_|_| |_|
%                                       
% ================================================================================================================

\subsection{Булевы операции}\label{sec:Boolean}

Форма объёма может быть задана как примитив либо Булева операция над примитивами или результатами Булевых операций, причём работает такое правило, что первый операнд каждой операции не должен подвергаться каким-либо преобразованиям координат. При создании Булевых операции матрица позиционирования второго операнда относительно первого задаётся трёмя поворотами вокруг стандартных фиксированных осей и одним сдвигом --- также, как и при позиционировании дочернего объёма в материнском. Разница заключается в том, что порядок поворотов обратный --- сначала вокруг X, затем вокруг Y и вокруг Z. Сдвиг выполняется после поворотов.

Определено три Булевы операции (приведены оригинальные названия в GEANT/ROOT и соответствующие названия в CATIA~v5):

\begin{itemize}
\item{Объединение (Union, Add);}
\item{Вычитание (Subtraction, Remove);}
\item{Пересечение (Intersection, Intersect).}
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{pictures/Boolean.eps}
\caption{Булевы операции.}
\label{fig:Boolean}
\end{figure}

Операндом и результатом Булевой операции в MC-модели в CATIA~v5 по правилам ``Builder'' является тело --- объект типа Body. Для того, чтобы создать Булеву операцию необходимо к телу, обозначающему результат, присоединить первый операнд с помощью формообразования Assemble, а второй с помощью одного из формообразований Add, Remove, Intersect в зависимости от типа операции. Если операнд это просто примитив, то в теле будет одно формообразование типа UDF. Второй операнд может также иметь преобразования координат.

\todo картинка и описание примера с несколькими уровнями вложенности

\todo \textbf{В принципе хочется добавить что-то ещё, но что конкретно?}

% ================================================================================================================
%  ____                                _            _          _   _             
% |  _ \ __ _ _ __ __ _ _ __ ___   ___| |_ ___ _ __(_)______ _| |_(_) ___  _ __  
% | |_) / _` | '__/ _` | '_ ` _ \ / _ \ __/ _ \ '__| |_  / _` | __| |/ _ \| '_ \ 
% |  __/ (_| | | | (_| | | | | | |  __/ ||  __/ |  | |/ / (_| | |_| | (_) | | | |
% |_|   \__,_|_|  \__,_|_| |_| |_|\___|\__\___|_|  |_/___\__,_|\__|_|\___/|_| |_|
%                                                                                
% ================================================================================================================

\subsection{Параметризация}\label{sec:Parameterization}

Одна из наиболее важных возможностей ``CATIA-GDML geometry builder'' --- это возможность создания параметризованных геометрических MC-моделей. У параметризованной модели имеются входные параметры и формулы, задающие зависимость между этими входными параметрами и внутренними переменными, такими как параметры примитивов, значения поворотов и смещений. Данная концепция хорошо ложится на методы работы с геометрией в САПР, особенно CATIA~v5. Также параметризация поддерживается форматом GDML и импортёрами GEANT4(\todo) и ROOT.

В модели CATIA~v5 можно вводить пользовательские параметры как в документах типа CATProduct, так и в документах типа CATPart. Причём сборка в CATProduct файле может иметь свои пользовательские параметры и формулы, а дочерние компоненты в CATPart файлах --- свои. Обязательное требование ``Builder'' таково, что все параметры и формулы должны находиться в верхнем продукте. CATIA~v5 позволяет задавать зависимости между любыми параметрами, в том числе внутренними, не являющимися пользовательскими, однако для успешного экспорта в GDML файл формула должна в левой части иметь параметр примитива или угол поворота или значение сдвига, а в правой части --- формулу только над пользовательскими параметрами. Пользовательский параметр CATIA~v5, экспортируемый в переменную в GDML должен обязательно иметь безразмерный тип Real. В связи с этим имеются правила оформления формул и приведения единиц измерения. Также имеется стандартная переменная DEGtoRAD для перевода значения углов из градусов в радианы.

На выходе получается GDML файл, у которого в define секции есть тэги variable, обозначающие входные параметры модели со значениями. При импорте параметризованной геометрии из GDML в ROOT все значения внутренних переменных рассчитываются в соответствии с формулами по значениям входных параметров и параметризация теряется. Следовательно значения входных параметров должны задаваться пользователем непосредственно в GDML файле перед импортом в конечную систему.

% ================================================================================================================
%  _____                  _       _           _ 
% |_   _|__  ___ ___  ___| | __ _| |_ ___  __| |
%   | |/ _ \/ __/ __|/ _ \ |/ _` | __/ _ \/ _` |
%   | |  __/\__ \__ \  __/ | (_| | ||  __/ (_| |
%   |_|\___||___/___/\___|_|\__,_|\__\___|\__,_|
%                                               
% ================================================================================================================

\subsection{Тесселированная геометрия}\label{sec:Tesselated}

\todo см. секцию~\ref{sec:secGeoPoly}

В GEANT/ROOT реализована поддержка триангулированной геометрии, однако специфика этих систем накладывает строгое ограничение --- с помощью треугольников должна быть описана только замкнутая оболочка, ограничивающая область пространства с заданным материалом, т.е. по сути объём.
%Мы знаем юз-кейс.
Для реализации поддержки триангулированной геометрии в ``CATIA-GDML geometry builder'' были разработаны правила её хранения в модели и необходимый код в конвертерах \macroname{CATIA2GDML} и \macroname{GDML2CATIA}.

\todo \textbf{описание реализации в билдере}

% ================================================================================================================
%  ____        _ _     _                                                  
% | __ ) _   _(_) | __| | ___ _ __     _ __ ___   __ _  ___ _ __ ___  ___ 
% |  _ \| | | | | |/ _` |/ _ \ '__|   | '_ ` _ \ / _` |/ __| '__/ _ \/ __|
% | |_) | |_| | | | (_| |  __/ |      | | | | | | (_| | (__| | | (_) \__ \
% |____/ \__,_|_|_|\__,_|\___|_|      |_| |_| |_|\__,_|\___|_|  \___/|___/
%                                                                         
% ================================================================================================================

\subsection{Макропрограммы для CATIA~v5}\label{sec:secMacros}

Макропрограммы для CATIA~v5 написаны на VBA с применением CATIA~API. Все макропрограммы, кроме \macroname{AddShape} и \macroname{Poly}, доступны пользователю в режиме работы над сборкой. В CATIA~v5 различают открытый документ (верхний в дереве в текущем окне), активный документ (синий), выделенный объект (оранжевый) и рабочий объект (подчёркнутый). Пользователь может выполнить все операции, необходимые для получения MC-модели, самостоятельно без применения макропрограмм, но в этом случае велика вероятность упустить какой-либо шаг, что приведёт к ошибке, которую сложно диагностировать.

В MC-модели в CATIA есть строгие правила именования. Применение макросов избавляет пользователя от необходимости контролировать имена объектов в документах. Все имена, сгенерированные при использовании ``Builder'' не конфликтуют между собой и позволяют получить корректный GDML файл на выходе. Практически везде пользователь имеет право изменять суффиксы, не изменяя основного названия, несущего информацию о типе объекта --- формообразования, тела, и т.д. Однако в редких случаях суффикс имеет решающее значение, как например в именах поворотах (напр, ``Rotate.X'') суффикс несёт информацию об оси поворота.

В процессе разработки ``Builder'' был выработан стандартный алгоритм создания геометрии. Первый шаг --- создание нового документа типа CATProduct, который в дальнейшем будет единственным продуктом, и его сохранение на диск. Этот продукт будет представлять модель всей экспериментальной установки. Второй этап --- наполнение продукта описанием объёмов без описания взаимосвязей между ними. Для этого используется макрос \macroname{AddNewPart}, который автоматически открывает в отдельном окне новый документ типа CATPart, сформированный из специального шаблона и соответствующий создаваемому объёму. Система переходит в режим редактирования детали, где доступны только два макроса \macroname{AddShape} и \macroname{Poly} для создания формы объёма. Здесь же можно и задать имя материала объёма. По окончании редактирования нового объёма в отдельном окне пользователь должен сохранить активный документ и закрыть это окно. CATIA при этом возвращается к редактированию продукта. После того, как созданы объёмы, заданы формы и, возможно, имена материалов, алгоритм подразумевает задание иерархии объёмов, то есть позиционирование одних объёмов в других. Для этого в ``Builder'' существует целый ряд макропрограмм для создания различных типов взаимосвязей --- \macroname{Inserter}, \macroname{ArrayMaker}, \macroname{Replica}. После того, как выполнено размещение дочернего объёма $A$ в материнском объёме $B$, пользователь может указать поворот и сдвиг, задающие матрицу позиционирования $A$ в $B$. Для упрощения расчётов в некоторых случаях очень удобно применять макропрограммы \macroname{PointToPointAligner} (\macroname{Pt2PtAligner}), \macroname{Mover} и \macroname{Measure}. Для удобного редактирования материалов всех объёмов был разработан менеджер материалов \macroname{MaterialsManager}, который обычно имеет смысл вызывать перед экспортом для проверки ранее заданных имён материалов, либо назначения новых. Также перед экспортом рекомендуется проверить модель на наличие ошибок с помощью макроса \macroname{Checker}. В конце выполняется экспорт макросом \macroname{CATIA2GDML}. Отдельно стоят макропрограммы \macroname{Duplicator} для создания множественных идентичных, но не связанных, параметризованных подсборок и обратный конвертер \macroname{GDML2CATIA} для импорта GDML файла.

% Дублирование. Выше уже есть об окружении
Для комфортной работы с ``Builder'' в поставке также имеются файлы для настройки окружения CATIA. Использования окружения в принципе не обязательно, но часть функционала зависит от путей к файлам, которые прописаны в переменных окружения, поэтому настоятельно рекомендуется перед использованием ``Builder'' выполнить настройку, следуя инструкции, поставляемой в пакете.

\subsubsection{\macroname{AddNewPart}}\label{sec:secMacroAddNewPart}

Данная макропрограмма автоматизирует создание нового документа типа CATPart на основе шаблона, содержащего необходимые элементы --- публикация главного тела детали, называемая PartBody, пользовательский параметр под названием Material со значением по умолчанию vacuum. Для удобства работы в файле шаблона и во всех генерируемых новый документах типа CATPart погашены стандартные плоскости. Созданный документ автоматически сохраняется на диск в папку, в которой выполняется построение модели, и которая автоматически определяется из открытого документа типа CATProduct в момент вызова макроса. Путь можно изменить в окне графического интерфейса. Также созданная деталь добавляется в качестве компонента в открытую сборку. Новый документ открывается в дочернем окне CATIA и пользователь может как начать работу над объёмом, так и оставить его пустым и отложить редактирование. Достаточно закрыть это окно и система перейдёт обратно к редактированию сборки.

\subsubsection{\macroname{AddShape}}\label{sec:secMacroAddShape}

\macroname{AddShape} используется для создания примитивов, в случае необходимости вместе с поворотами и сдвигом. Макропрограмма играет роль интерфейса между пользователем и файлами примитивов. При запуске макроса выводится окно со списком доступных примитивов, по нажатии на кнопку ``создать'' в рабочее тело детали вставляется выбранный примитив со значениями параметров по умолчанию. Если на форме графического интерфейса выбраны флаги создания поворотов и сдвига, то создаются соответствующие формообразования. Если форма объёма состоит из одного примитива, то повороты и смещение запрещены. Они имеют смысл только при содании второго операнда Булевой операции. Список примитивов формируется из списка файлов, имеющихся в папке примитивов, определённой с помощью относительного пути в BuilderPath.

\subsubsection{\macroname{Poly}}\label{sec:secMacroPoly}

В силу ограничений CATIA нет возможности представить полипримитивы (polycone и polyhedra) с помощью тех же средств, что и остальные примитивы, поэтому для них была разработана специальная структура дерева и правила именования. Для автоматизации построения полипримитивов в соответствии с этой структурой предоставляется макрос \macroname{Poly}. Секции поликонуса представлены стандартными конусами. В случае polyhedra для представления секции используется hedra --- специальный примитив, не поддерживаемый GEANT/ROOT.

\subsubsection{\macroname{Inserter}}\label{sec:secMacroInserter}

Макрос \macroname{Inserter} --- это инструмент для помещения одного выбранного объёма в другой. Также можно сказать, что \macroname{Inserter} создаёт физический объём, задающий связь материнский-дочерний между двумя существующими логическими объёмами. \macroname{Inserter} --- возможно, самый используемый макрос, в результате работы которого в документе типа CATPart, представляющем материнский объём, создётся тело с именем ``Body.B.*'', где $B$ --- имя дочернего объёма. Внутри этого тела имеется ссылка на публикацию PartBody документа типа CATPart, представляющего объём $B$, и элементы преобразования типа Rotate и Translate --- три поворота и сдвиг, задающие матрицу позиционирования $B$ внутри $A$. Повороты выполняются вокруг фиксированных стандартных осей, а порядок строго определён --- сначала вокрус оси Z, затем вокрус оси Y и в конце вокрус оси X. Следует отметить, что такие повороты не являются преобразованиями Эйлера, где система кординат вращается вместе с телом и оси меняют своё направление.

\subsubsection{\macroname{ArrayMaker}}\label{sec:secMacroArrayMaker}

%Надо вообще где-то сказать, что в кате есть массив, который конвертируется в независимые вхождения.

Макрос \macroname{ArrayMaker} схож с \macroname{Inserter} по идее и реализации. После выполнения вставки дочернего объёма в материнский, к созданному телу добавляется формообразование pattern вдоль указанной оси и с указанными шагом и количеством вхождений.

\subsubsection{\macroname{Replica}}\label{sec:secMacroReplica}

Одна из продвинутых возможностей геометрической подсистемы GEANT/ROOT --- это деление объёмов. В GEANT4 эта возможность называется replica, а в ROOT --- division. Суть заключается в том, что допускается деление некоторого объёма путём разрезания через равные промежутки вдоль одной из четырёх осей --- X, Y, Z и $\phi$, где $\phi$ --- круговое направление. В результате деления получается набор одинаковых под-объёмов --- долек, которые можно рассматривать как независимые вхождения одного объёма и позиционировать внутри другие объёмы. Отличие дольки от обычного объёма заключается в том, что для долек оптимизирована реализация проведения частиц. (\todo сформулировать лучше) Деление возможно только для ограниченного числа форм, таких, что все доли имеют одинаковую форму. Box --- в любом из трёх линейных направлений X, Y или Z. Tubs --- вдоль оси цилиндра, то есть вдоль линейной оси Z, или вдоль круговой оси $\phi$. Дальше продолжать\todo 

За счёт того ограничения, что формы долек должны быть одинаковы, для описания разделённых объёмов в CATIA решено использовать тот же принцип, что и для описания массивов с тем отличием, что имя формообразования pattern должно соответствовать шаблону ``Replica.Axis'', где Axis --- ось реплицирования. За счёт того ограничения, что дольки должны заполнять всё пространство материнского объёма возможен автоматический расчёт геометрических размеров дольки по двум входным параметрам --- направлению деления и количеству.

\subsubsection{\macroname{PointToPointAligner}}\label{sec:secMacroPtPAligner}

\macroname{PointToPointAligner} автоматизирует процесс позиционирования дочернего объёма внутри материнского. При вложении одного объёма в другой необходимо задать положение дочернего объёма в материнском. В ``Builder'' для этого используется три формообразования типа Rotate --- последовательные повороты вокруг трёх фиксированных стандартных осей Z, Y и X --- и одно типа Translate --- параллельный сдвиг. Пользователь должен каким-то образом рассчитать значения углов и координаты сдвига. Типовая процедура определения этих значений заключается в том, что пользователь использует стандартные средства CATIA для измерения углов и расстояний и затем вручную записывает эти значения в соответствующие параметры. В случае сложного поворота практически невозможно получить углы поворота прямым измерением, требуется активное интеллектуальное участие пользователя. Определение смещения, которое выполняется после всех поворотов, прямолинейно, но требует выполнения достаточно большого количества механических операций, которые автоматизированы в \macroname{PointToPointAligner}.

Этот макрос предоставляет пользователю возможность выбрать две точки, которые совместятся придвижением первой ко второй. Первая точка должна быть вершиной, принадлежащей телу, обозначающему дочерний объём --- только в этом случае в макропрограмме представляется возможным определить, какому телу принадлежит выбранная вершина, чтобы выбрать формообразования, описывающие матрицу позиционирования, которую необходимо изменить. Вторая точка может быть полученной в результате любой операции --- это может быть как вершина тела, так и каркасный элемент. Для неё определяются только координаты, чтобы рассчитать сдвиг как разность координат двух точек.

\subsubsection{\macroname{Mover}}\label{sec:secMacroMover}

Нередко возникает такая ситуация, что требуется подвинуть группу дочерних объёмов внутри одного материнского на одинаковое расстояние. Если использовать существующие средства CATIA, то нет никакого способа выполнить этот сдвиг для нескольких объёмов сразу. В ручном режиме пользователю требуется осуществлять сдвиг для каждого объёма отдельно путём изменения значений параметров формообразования Transltate, отвечающего за позиционирование дочернего объёма в материнском. Чтобы автоматизировать этот процесс был разработан \macroname{Mover}. При использовании \macroname{Mover} пользователь выбирает какие дочерние объёмы он хочет подвинуть и на какое расстояние в графическом интерфейсе.

\subsubsection{\macroname{Measure}}\label{sec:secMacroMeasure}

Макропрограмма \macroname{Measure} автоматизирует процесс измерения и записи результата измерения в какой-либо параметр модели. Необходимость выполнения подобной операции особенно часто возникает при работе одновременно с исходной САПР моделью и разрабатываемой MC-моделью. Если требуется измерить какое-либо расстояние между объектами или размер какого-либо геометрического элемента, то пользователь может воспользоваться стандартными средствами CATIA ``Measure between'' и ``Measure item'' соответственно. В результате появляется окно с результатами измерения, обычно включая компоненты по координатам. Чтобы перенести эти результаты измерения куда-либо необходимо выделить и скопировать значение из поля, закрыть окно измерения, найти параметр в MC-модели, открыть его для редактирования и вставить в качестве значения содержимое буфера обмена. При использовании \macroname{Measure} список параметров модели отображается в окне графического интерфейса. Пользователь сначала выбирает тип измерения, затем выбирает измеряемые объекты в области геометрии. Результаты измерения выводятся в окне графического интерфейса и для того, чтобы записать выбранный результат в какой-либо параметр MC-модели, достаточно выбрать его в списке параметров.

\subsubsection{\macroname{MaterialsManager}}\label{sec:secMacroMaterialsManager}

Приложение \macroname{MaterialsManager} предоставляет пользователю возможность изменять материалы отдельных объёмов, находясь на уровне верхнего продукта. Это избавляет от необходимости часто переключаться между документами либо режимами работы в случае контекстного редактирования. Также заметным преимуществом использования \macroname{MaterialsManager} является наглядность --- информация о материалах всех объемов представляется в компактном списке, присутствует возможность быстро изменять значения в нескольких элементах списка. Помимо этого, наличие \macroname{MaterialsManager} позволяет отложить работу с материалами на последний этап. Использование шаблона файла детали предотвращает от того, что пользователь вообще не укажет материал объема --- по умолчанию указан вакуум (vacuum). В графическом интерфейсе \macroname{MaterialsManager} представлена таблица из трёх столбцов --- имя документа (объём), текущий материал, новый материал. Все изменения применяются только к этому списку до тех пор, пока пользователь не нажмёт кнопку ``Modify materials in documents'' и изменения не внесутся в соответствующие документы типа CATPart.

\subsubsection{\macroname{Checker}}\label{sec:secMacroChecker}

Чтобы ускорить процесс моделирования необходимо отлавливать ошибки на как можно более раннем этапе. Макрос \macroname{Checker} позволяет выполнять проверку правильности построенной пользователем MC-модели в CATIA до экспорта в GDML, таким образом сокращая время отладки, которое ушло бы на экспорт геометрии в GDML, импорт в GEANT/ROOT и запуск проверки в конечной системе. Необходимость проверки возникает в силу того, что в разработанной структуре документов CATIA для MC-модели введено множество правил и ограничений, нетипичных для \todo conventional использования системы. \macroname{Checker} выполняет 2 типа проверок. Первый --- корректность с точки зрения конвертера, т.е. соблюдение структуры документов, правильность именования, второй --- корректность с точки зрения правил построения геометрии в GEANT/ROOT.

Использование разработанных интерактивных приложений ограждает пользователя от ошибок именования в итоговой MC-модели. Есть только одно место, где необходимо вручную указывать имя --- формообразование-вращение при позиционировании операнда на уровне формы (\todo уточнить). В любом случае, пользователь в праве редактировать модель не применяя макросы --- это ускоряет процесс в некоторых случаях, но повышает вероятность нарушения правил именования. Принципиальные ошибки в структуре документов MC-модели с большой долей вероятности приведут к некорректному завершению \macroname{Checker}, потому что практически невозможно автоматически их проверять.

Корректность геометрии определяется по двум критериям:
\begin{enumerate}
\item любые два объёма, находящиеся на одном уровне, не должны пересекаться;
\item любой дочерний объём не должен выходить за пределы материнского объёма.
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{pictures/Checker.eps}
\caption{Логические операции для определения правильности позиционирования объёмов.}
\label{fig:CheckerOperations}
\end{figure}

Чтобы организовать проверку указанных условий, разработан специальный алгоритм и реализован в виде отдельной макропрограммы \macroname{Checker} САПР CATIA. В цикле перебираются все пары объёмов, лежащих на одном уровне, и проверяется, не пусто ли множество пересечения текущей пары. В том случае, если не пусто, то возникает событие, оповещающее, что текущая пара объёмов расположена недопустимым образом.

Более детально описанный процесс выглядит следующим образом. В силу того, что физические объёмы описываются телами детали, перебор объёмов, лежащих на одном уровне, сводится к перебору всех тел детали, кроме PartBody. Чтобы исследовать множество пересечения пары тел, создаётся новое пустое тело и копии исходных. Затем применяется Булева операция Intersect над копиями, и результат заносится в ранее созданное пустое тело. На этапе выполнения формообразования булевой операции выдаётся возможность отследить корректность результата. С точки зрения CATIA пустое пересечение является ошибочным результатом и возникает внутренняя ошибка. Именно программный отлов и обработка этой ошибки говорит о корректности расположения объёмов. После выполнения булевой операции результирующее тело удаляется, не оставляя таким образом никаких следов промежуточных преобразований.

Для того чтобы отследить, не выходит ли объём за пределы материнского объёма, применяется схожий подход. Отличие заключается в последовательности булевых операций --- вместо пересечения $A*B$ двух объёмов $A$ и $B$ проверяется объём, полученный последовательностью двух операций $(A+B)-A$, где $A$ --- материнский объём, а $B$ --- дочерний. Присутствие результата операции $(A+B)-A$ говорит о том, что какая-либо часть дочернего объёма расположена за пределами материнского.

\subsubsection{\macroname{CATIA2GDML}}\label{sec:CATIA2GDML}

Конвертер \macroname{CATIA2GDML} проецирует дерево потроения MC-модели из CATIA~v5 в GDML файл. За счёт того, что правила построения MC-модели в CATIA формулировались с ориентиром на структуру, принятую в GEANT/ROOT, базовый функционал прямого конвертера заключается в том, что он создаёт в выходном GDML файле сущности, соответствующие найденным объектам в дереве построения в CATIA. Важной особенностью является то, что конвертер не обращается к самой геометрии, вся необходимая информацию содержится в дереве построение модели.

Помимо прямолинейного отображения дерева модели в GDML, в \macroname{CATIA2GDML} осуществляется преобразование некоторых особенностей, введённых в CATIA для упрощения процесса моделирования. Так, например, для отображения массива (см. \ref{} \todo), которого нет в возможностях GDML, макрос рассчитывает повороты и положения каждого вхождения и создаёт независимые дочерние объёмы в GDML. В случае линейный массивов задача проста. Описание \todo В случае круговых массивов расчёт выполняется с применением матричных преобразований, обсуждаемых в~\ref{sec:secMatrices}.

В дереве CATIA нет обособленного списка используемых в модели материалов, поэтому для создания такого в GDML выполняется нехитрый алгоритм, который при проходе в цикле по объёмам добавляет в выходной список имя материала, если такого ещё нет.

% Цвет
В ``Builder'' реализована возможность переноса цвета объёма с помощью вспомогательного тега auxilliary в GDML файле, который позволяет добавлять произвольное поле данных к описанию логического объёма. Цвет тела в CATIA никак не отображается в дереве, поэтому для формирования тега при экспорте модели опрашиваются параметры вызуализации главного тела PartBody детали, содержащие в том числе и цвет.

\subsubsection{\macroname{GDML2CATIA}}\label{sec:GDML2CATIA}

\macroname{GDML2CATIA} выполняет процедуру, обратную \macroname{CATIA2GDML} --- проецирует GDML файл на дерево модели CATIA~v5. В ``Builder'' есть возможность задавать линейные и круговые массивы --- многократные вхождения дочернего объёма в материнский, позиционированные с некоторым шагом вдоль линейной или круговой оси соответственно. В MC-модели в CATIA для массивов применяется соответствующее стандартное формообразование pattern. Такая возможность отсутствует в GDML, поэтому при экспорте из CATIA в GDML выполняется расчёт поворотов и сдвигов для каждого элемента массива и они представляются как отдельные, независимые дочерние объёмы. Таким образом при конвертации в обратном направлении, из GDML в CATIA, невозможно восстановить массив. Следовательно, одна из немногих (единственная \todo) операций, которые необходимо совершать после импорта геометрии из GDML в CATIA --- ручной перевод множества дочерних объёмов в массив. Обычно это очень простая процедура, и заключается она в том, что удаляются все вхождения, кроме первого, и в список формообразований первого тела добаляется pattern, которому задаются необходимые параметры и имя.

% Цвет
Аналогично прямому конвертеру, для передачи цвета автоматически выполняется дополнительная операция присвоения параметров визуализации тела если в GDML встречается тэг auxilliary.

\subsubsection{\macroname{Duplicator}}\label{sec:Duplicator}

Создание MC-модели более-менее сложной экспериментальной установки обычно требует создания нескольких вхождений параметризованных подборок с разными значениями параметров. Можно привести следующий пример. Рассмотрим детектор, состоящий из однотипных модулей, содержащих массив чувствительных объёмов (сенсоров), и какие-то другие элементы, например, платы передней электроники. Предположим, что существует несколько типоразмеров модулей, отличающихся количеством и размером сенсоров. Таким детектором может быть, например, калориметр, построенный из нескольких типов модулей, отличающихся гранулярностью --- размер чувствительного объёма увеличивается по мере удаления от пучка. Очевидно, что если типы модулей отличаются лишь значениями каких-либо переменных, то представляется возможным построить одну параметризованную модель модуля, чтобы дальше использовать её многократно для построения всего детектора. К сожалению в GEANT/ROOT нет возможности так сделать --- нужно для каждого типа иметь отдельное определение геометрии. Также это невозможно и в GDML и в CATIA.

В модели для каждой комбинации параметров, то есть для каждого модуля в нашем примере, должна существовать отдельная параметризированная подсборка. При этом имена всех объёмов должны отличаться, а наборы параметров для каждого модуля должны быть независимы. В CATIA нет возможности быстро создать копию подсборки вместе со всеми параметрами и зависимостями.

Для того, чтобы атоматизировать процесс создания такой копии используется \macroname{Duplicator}.
Работа с \macroname{Duplicator} выполняется в 2 этапа.

\todo

\subsubsection{Визуализация нескольких уровней вложенности объёмов}\label{sec:MultiLevelVis}

В соответствии со структурой документов, определённых в ``CATIA-GDML geometry builder'', в один момент можно визуализировать только один уровень вложенности.

Для того, чтобы визуализировать несколько уровней вложенности в CATIA предлагается следующий подход. Во всех документах типа CATPart, то есть для всех объёмов, все тела, обозначающие дочерние объёмы, вычитаются из главного тела PartBody. За счёт того, что в документе, описывающем материнский объём, у тел, обозначающих дочерние объёмы, есть ссылка на PartBody деталей, 
\todo

% ================================================================================================================
%  ____  __  __ _   _                 _   _           _              
% |  _ \|  \/  | | | |     ___  _ __ | |_(_)_ __ ___ (_)_______ _ __ 
% | | | | |\/| | | | |    / _ \| '_ \| __| | '_ ` _ \| |_  / _ \ '__|
% | |_| | |  | | |_| |   | (_) | |_) | |_| | | | | | | |/ /  __/ |   
% |____/|_|  |_|\___/     \___/| .__/ \__|_|_| |_| |_|_/___\___|_|   
%                              |_|                                   
% ================================================================================================================

\subsection{Применение CATIA DMU Optimizer для построения MC-геометрии}\label{sec:CATIAoptimize}

САПР CATIA~v5 в своём составе имеет модуль DMU Optimizer, который позволяет решать задачу оптимизации. Пользователь должен сформировать критерий и определить входные параметры, возможно с допустимыми диапазонами изменения. Также необходимо выбрать один из трёх вариантов постановки задачи оптимизации --- приведение критерия к минимуму, максимуму, либо целевому значению. В качестве критерия можно выбрать существующий параметр системы CATIA~v5 либо задать аналитическое выражение над параметрами. Отдельно стоит упомянуть возможность выбора результата измерения в качестве критерия оптимизации. Например, имеется возможность средствами CATIA задать измерение расстояния или угла между камими-либо геометрическими элементами, измерение длины элемента, или даже площади или объёма элемента.

Допустим, имеется геометрическая модель объекта, которую необходимо перевести в MC-совместимый формат с упрощением геометрии, но сохранением габаритов, например подробная инженерная модель некоторого узла, упрощаемого до одного объёма. В этом случае наиболее эффективный вариант это сначала создать структуру формы с приблизительными размерами ``на глаз'', а затем с помощью оптимизации подобрать размеры примитивов. Критерий может быть составлен, например, как сумма квадратов расстояний между соответствующими точками САПР-модели и MC-модели, а входные параметры --- все или некоторые размеры примитивов, параметры позиционирования операндов.
Как второй, более сложный вариант, можно создать измерение объёма деталей узла, измерение объмов MC-геометрии и поставить задачу минизмизации их разницы. При этом, однако, нужно предварительно очень тщательно продумать структуру МС-геометрии и ограничить как можно больше параметров.

В качестве свободных параметров, помимо параметров формы, можно использовать параметры повоторов и сдвига при позиционировании дочернего объёма внутри материнского или позиционировании Булевых операндов. Возможна ситуация, когда оптимизируется только положение, но не размеры. Оптимизация имеет смысл, когда прямое измерение невозможно. Например, если положение объёма получено сложным поворотом, то практически невозможно понять, как представить этот поворот с помощью комбинации трёх последовательных поворотов вокруг фиксированных осей в требуемом порядке (Z, Y, X для объёмов и X, Y, Z для операндров). Один из вариантов решения данной ситуации --- минимизация суммы квадратов углов между соответствующими линиями САПР-модели и MC-модели. Если же поворот дочернего объёма уже задан верно, то нет смысла запускать оптимизацию для нахождения параметров сдвига. Их можно получить прямым измерением расстояния между двумя соответствующими точками. CATIA показывает кратчайшее расстояние и, если включена соответствующая настройка, компоненты вектора, которые и являются параметрами сдвига. Макропрограмма \macroname{PointToPointAligner} (см. секцию~\ref{sec:secMacroPtPAligner}) автоматизирует данную процедуру.

Алгоритмы оптимизации итерационные, что означает, что система пытается найти значения входных параметров, дающих наиболее оптимальное значение критерия, путём перебора различных комбинаций в соответствии с некоторым алгоритмом. В DMU Optimizer реализовано несколько алгоритмов оптимизации. Разные алгоритмы наиболее эффективны в разных ситуациях, поэтому стоит попробовать другой алгоритм, если оптимизация не сходится. Если в качестве критерия оптимизации задан результат измерения или аналитическое выражение с использованием результата измерения, то на каждой итерации, после изменения входных параметров, система автоматически обновляет геометрическую модель для того, чтобы рассчитать значения измерений. В связи с этим оптимизация может занять значительное время (10-20 мин.) для сложных моделей.

% Диапазон
Имеется возможность задания диапазонов изменения входных параметров оптимизации. Эта возможность бывает удобна, если есть какая-либо предварительная информация или возможно оценить значение ``на глаз''.
\todo Теоретически, наличие диапазонов входных параметров сильно упрощает работу алгоритму оптимизации. Ещё лучше, если все параметры имеют заданные диапазоны. \todo \textbf{Тут нужно как-то гладко сказать. Так-то теоретически, если заданы все диапазоны, и критериальная функция непрерывная, то гарантировано нахождение оптимума некоторыми алгоритмами. Но не факт, что теми, которые есть к CATIA.}
Очевидно, что повороты должны быть ограничены диапазоном шириной $\SI{360}{\degree}$, например от $\SI{-180}{\degree}$ до $\SI{180}{\degree}$. Если не задать диапазон, то алгоритм может пробовать различные значения, кратные $\SI{360}{\degree}$ и приводящие к одинаковому результату, что может сделать процесс оптимизации бесконечным.

% Управляющие параметры
Для управления процессом оптимизации в CATIA~v5 предусмотрено несколько управляющих параметров. Пользователь может задать максимальное количество итераций, максимальное количество итераций без улучшения, максимальное время оптимизации, и др. \todo
(Из общих сведений об оптимизации)
Широко известно, что критериальная функция часто имеет множество локальных оптимумов и один или несколько глобальных оптимумов. Это необходимо учитывать при подгоне MC-геометрии к САПР-модели с помощью DMU Optimizer. Некоторые алгоритмы оптимизации основаны на генерировании случайных чисел, поэтому имеет смысл многократно запускать оптимизацию, если результат первого прогона не является удовлетворительным. Также имеет смысл повторно запускать оптимизацию с другими начальными значениями для получения альтернативных решений. В некоторых алгоритмах уже реализован мультистарт, поэтому необходимо увеличивать максимальное допустимое время расчёта и максимально допустимое количество итераций, чтобы система могла перебрать больше вариантов.

В целом, можно сказать, что оптимизация --- это полезный инструмент, с помощью которого можно решить некоторые проблемы, не решаемые другими способами. Однако невозможно свести нахождение всех параметров MC-модели к одной задаче оптимизации, т.к. с каждым новым входным параметром вырастает сложность проблемы и время, необходимое для решения. Более того, правильно составить критерий сложнее, чем явно задать размер примитива или параметр позицирования, например с помощью измерения. \textbf{Всё-таки подавляющее большинство форм --- боксы и цилиндры, расположенные вдоль стандартных осей.}
