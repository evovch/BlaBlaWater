\section{Программное обеспечение}\label{section:secSoft}

Программное обеспечение системы считывания и сбора данных прототипа CBM~RICH представляет собой набор модулей приема, первичной обработки и сохранения данных, реализованных в рамках программного каркаса CbmRoot~\cite{CBMROOT}. CbmRoot вместе в FLESnet~\cite{FLESnet} образуют инфраструктуру позволяющую выполнять приём данных, моделирование, реконструкцию и анализ данных эксперимента CBM.

Соответствующим образом сконфигурированное приложение, написанное в рамках CbmRoot, может быть запущено на ЭВМ, как частный случай на распределенной вычислительной системе. Все этапы от считывания до анализа могут быть выполнены <<на лету>>, без записи промежуточных результатов на диск. В ходе описываемых в данной статье тестов использовалась последовательность обработки данных, изображённая на рисунке~\ref{fig:SoftDiag}. Программная реализация, функционал и взаимодействие отдельных блоков описаны ниже.

\begin{figure}
\includegraphics[width=0.6\textwidth]{pictures/13_Software_diagram.eps}
\caption{Диаграмма взаимодействия программных модулей.}
\label{fig:SoftDiag}
\end{figure}

(Напишите об особенностях софта для работы с данными в случае использования FLIB.)

\subsection{Распаковка}

Распаковка это первый этап обработки данных, поступающих с электроники. В CbmRoot есть возможность обрабатывать данные как поступающие напрямую с детектора, так и сохранённые в файле (с помощью DABC в формате hld --- HADES list mode data format~\cite{HLD}).

Распаковка реализована как task-класс CbmRichTrbUnpack и в результате выполнения каждой итерации на выходе формируется TClonesArray с объектами класса CbmTrbRawMessage.

\subsection{Калибровка точного времени}

В процедуре калибровки точного времени воплощена известная техника калибровки счётчика цифровой линии задержки, реализованного с помощью технологии Tapped delay line \cite{TDLCALIB}, основанная на том, что распределение времен прихода сигналов должно быть равномерным по временному интервалу, занимаемому всеми элементами задержки. В результате анализа набранной порции данных для каждого канала строится дискретная функция $ f_{calib}(Fine) $, называемая таблицей перехода от значения счётчика к значению точного времени в наносекундах. При использовании таблицы калибровки точного времени полное время вычисляется как $ T = Epoch \cdot 2048 \cdot 5 + Coarse \cdot 5 - f_{calib}(Fine) $ нс.

Процедура калибровки точного времени реализована в singleton-классе CbmTrbCalibrator, который не является частью конвейера обработки данных --- обращение к объекту данного класса может производиться из любого места в программе. Присутствует возможность сохранения таблиц калибровки в отдельном файле, что ускоряет многократные расчёты за счёт повторного использования однократно рассчитанных таблиц.

\subsection{Коррекция задержек между каналами}

Для коррекции задержек между каналами в классе CbmTrbCalibrator реализована возможность импорта таблицы коррекций, построенной предварительно с помощью CmbRoot-макросов <<ExtractDelays>> и <<BuildDeltaTable>> на основе результатов первого прогона анализа. Первый макрос извлекает параметры гистограмм в текстовом виде из многочисленных файлов результатов анализа, полученных с помощью CbmRoot, возможно, с применением параллельных расчётов. Второй макрос стоит таблицу коррекций по данным параметрам.

Алгоритм коррекции задержек состоит в следующем. Введем сплошную нумерацию пикселей по всей фоточувствительной камере, состоящей из множества МА~ФЭУ. Полное число пикселей $ 64 \cdot N $, где N --- число МА~ФЭУ. Для анализа отбираются все передние фронты, имеющие временную отметку, попадающую в заданное временное окно относительно триггера срабатывания лазера. Ширина и положение окна зависят от экспериментальной установки (например разницы длин кабелей, точности регистрации триггера) и характеристик лазера и подбираются в соответствии с распределением, построенному по конкретному набору данных. Обычно ширина составляет около 100~нс, а левая граница сдвинута от триггера на 20~нс. По всему массиву отобранных данных строятся гистограммы разности временных отметок i-го и j-го каналов, где i~и~j пробегают значения от 1~до~N. В качестве меры разности задержек между каналами можно взять по выбору пользователя либо среднее значение распределения, либо наиболее вероятное. Полученные значения заполняют кососимметричную матрицу A размерности $ N \cdot N $. В дальнейшем пользователь может задать опорный канал, относительно которого будет создана таблица коррекций, являющаяся, по сути, столбцом матрицы~A.

\subsection{Построение хита}

Сигнал от каждого зарегистрированного фотона, называемый хитом, состоит из двух сообщений, содержащих временные отметки переднего и заднего фронтов. Т.к. разные каналы имеют разные задержки и вероятность регистрации отдельных фронтов не равна 100\%, необходимо было в анализе данных реализовать алгоритм подбора пар фронтов. Данная процедура реализована в task-классе CbmTrbEdgeMatcher, который стоит в конвейере после распаковки и фактически выполняется после применения всех калибровок.

Для каждого внешнего канала был реализован буфер сообщений, который наполнялся передними фронтами по мере их поступления. Далее, как только приходил задний фронт выбирался наиболее близкий по временной отметке передний фронт из буфера. На рисунке \ref{fig:EdgeMatching} приведён пример буфера передних фронтов для заданной пары внутренних каналов в момент прихода одного заднего фронта. Время над порогом (ToT) --- параметр хита, говорящий об амплитуде сигнала. Он вычисляется как разница временных отметок заднего и переднего фронтов в подобранной паре. Допускаются как положительные, так и отрицательные значения ToT, однако в обе стороны накладывается ограничение.

\begin{figure}
\includegraphics[width=1.0\textwidth]{pictures/14_Edge_matching_rus.eps}
\caption{Постановка задачи поиска пар фронтов для одного входного канала.}
\label{fig:EdgeMatching}
\end{figure}

Т.к. не всегда присутствует соответствующий парный (передний либо задний) фронт, буфер постепенно наполняется и его необходимо очищать, чтобы избежать переполнения. Если для поступившего заднего фронта нет кандидата переднего фронта в буфере это означает, что передний фронт не был зарегистрирован. В таком случае этот задний фронт отбрасывается. Количество ненайденных фронтов сильно зависит от нагруженности входного канала ВЦП, которая в свою очередь зависит от порога дискриминатора. При низком пороге регистрируется высокочастотный шум электроники, что приводит к формированию огромного потока формируемых сообщений, которые не могут быть переданы из-за ограниченной пропускной способности выходного тракта системы считывания.

Предусмотрена возможность принимать одиночные передние фронты в качестве хитов, однако практика показала, что в этом нет смысла, т.к. в нормальном режиме ненайденные пары в основном обусловлены ошибками ВПЦ, но доля таких сообщений пренебрежимо мала, менее $ 2 \cdot 10^{-4} $.

\subsection{Построение события}

В силу того, что электроника бестриггерная и приём данных осуществляется порциями данных (DAQ-события), никак не связанными с реальными событиями для формирования корректной входной информации для реконструкции и дальнейшего анализа данных, необходимо выполнять процедуру построения события.

\begin{figure}
\includegraphics[width=1.0\textwidth]{pictures/15_Event_building_rus_bw.eps}
\caption{Идея алгоритма построения события: (а) поступающие данные, сгруппированные в DAQ-события; (б) востановленные кандидаты реальных событий; перечёркнуты отбрасываемые кандидаты, не содержащие триггер. Тонкие длинные линии --- триггерные сигналы, прямоугольники средней длины --- сигналы, связанные со светом, короткие прямоугольники --- шумовые сигналы.}
\label{fig:EventBuilding}
\end{figure}

Рассмотрим некоторый интервал времени, приведённый на рисунке \ref{fig:EventBuilding}, в течение которого поступают:
\begin{itemize}
\item {Триггерные сигналы --- импульсы с генератора, питающего лазер, либо сигналы с детекторов пучка;}
\item {Сигналы, скорелированные с импульсами с генератора или детекторами пучка, т. е. связанные со светом;}
\item {Шумовые сигналы, распределённые равномерно во времени.}
\end{itemize}

Очевидно, что реальное событие может попасть на границу DAQ-событий, следовательно, необходимо при построении реальных событий смотреть на несколько DAQ-событий. Также в силу особенностей электроники не гарантируется, что входная информация поступает упорядоченной во времени. Поэтому периодически случается, что хиты реального события, пришедшего в i-м DAQ-событии обнаруживаются в i+1, реже i+2, и даже i+3 и последующих DAQ-событиях. Следовательно, требуется сначала распознать кластеры хитов в достаточно широком интервале времени --- потенциальные события, а затем по наличию заданного типа триггера выбрать реальные события, содержащие либо черенковские кольца, либо вспышки лазера.

Реализован данный алгоритм с помощью буфера хитов. По мере распаковки входных сообщений, построенные хиты заносятся в буфер. На каждой итерации осуществляется распознавание кандидатов событий в буфере и определяется их количество N.

Когда N достигает заданного минимального уровня, на каждой итерации, помимо приёма одного входного DAQ-события, осуществляется выброс выходного кандидата реального события. Так как одно DAQ-событие может содержать несколько кандидатов, буфер будет расти. Для того, чтобы избежать переполнения, устанавливается верхний предел. Когда N достигает этого предела, осуществляется сброс событий на выход по принципу FIFO до заданного минимального уровня. На рисунке \ref{fig:Buffer} приведён отрывок диаграммы наполненности буфера по мере обработки входного потока. В данном примере были установлены следующие параметры: минимальное кол-во событий в буфере 200, максимальное --- 500. Отметим, что количество событий в буфере может превышать заданное максимальное значение, если в одном DAQ-событии содержится более одного реального события.


\begin{figure}
\includegraphics[width=1.0\textwidth]{pictures/16_Buff.eps}
\caption{Диаграмма наполнености буфера найденных событий в зависимости от номера обработанного входного DAQ-события.}
\label{fig:Buffer}
\end{figure}

По окончании входного потока содержимое буфера обрабатывается полностью и все распознанные события подаются на выход.

\subsection{Реконструкция}

Реконструкция в CBM RICH означает поиск колец по хитам в плоскости реконструкции. Хит это загоревшийся пиксель ФЭУ. Конус черенковских фотонов, после фокусировки зеркалами, пересекает поверхность фоточувствительной камеры, которая в общем случае может состоять из нескольких плоскостей. Первый этап реконструкции --- перевод хитов из плоскостей камеры в плоскость реконструкции. Затем выполняется поиск колец по хитам. В CbmRoot есть реализации нескольких алгоритмов поиска колец. Наибольший практический интерес представляет алгоритм распознавания колец черенковского излучения, основанный на проеобразовании Хафа, описанный в работах \cite{RECOPEPAN, RECO2}. Реализация данного алгоритма была специально адаптирована для данных пучковых тестов, в которых ожидается одно кольцо на событие. Данный алгоритм реализован в классе CbmRichProtRingFinderHoughImpl, унаследованном от CbmRichProtRingFinderHough и далее от CbmRichRingFinder. После этого определяются параметры кольца и далее реконструкция с применением информации с других детекторов.
